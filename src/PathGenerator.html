<html>
<head>
<title>Path Generator</title>
<script src="math.js"></script>
</head>
<body>
<canvas id="myCanvas" width="800px" height="800px" style="width:400px;height=400px"></canvas>

<script>
var c = document.getElementById("myCanvas");
var context = c.getContext("2d");

//	Works for 5th degree polynomials
//	Takes in 2 pts, 2 velocity vectors, 2 acceleration vectors
function getPolynomialConstants(pt1, pt2, v1, v2, a1, a2)
{
	var matrixA = math.matrix([[Math.pow(pt1['x'], 5), Math.pow(pt1['x'], 4), Math.pow(pt1['x'], 3), Math.pow(pt1['x'], 2), Math.pow(pt1['x'], 1), 1],
					[Math.pow(pt2['x'], 5), Math.pow(pt2['x'], 4), Math.pow(pt2['x'], 3), Math.pow(pt2['x'], 2), Math.pow(pt2['x'], 1), 1],
					[5 * Math.pow(pt1['x'], 4), 4 * Math.pow(pt1['x'], 3), 3 * Math.pow(pt1['x'], 2), 2 * Math.pow(pt1['x'], 1), 1, 0],
					[5 * Math.pow(pt2['x'], 4), 4 * Math.pow(pt2['x'], 3), 3 * Math.pow(pt2['x'], 2), 2 * Math.pow(pt2['x'], 1), 1, 0],
					[20 * Math.pow(pt1['x'], 3), 12 * Math.pow(pt1['x'], 2), 6 * Math.pow(pt1['x'], 1), 2, 0, 0],
					[20 * Math.pow(pt2['x'], 3), 12 * Math.pow(pt2['x'], 2), 6 * Math.pow(pt2['x'], 1), 2, 0, 0]]);
	vDir1 = (v1['x'] == 0) ? 0 : v1['y'] / v1['x'];
	vDir2 = (v2['x'] == 0) ? 0 : v2['y'] / v2['x'];
	var matrixB = math.matrix([pt1['y'], pt2['y'], vDir1, vDir2, a1['y'], a2['y']]);
	var coefficients = math.multiply(math.inv(matrixA), matrixB);
	return coefficients._data;
}

function getPolynomialConstantsFromPtsOnly(points)
{
	var matrixArrA = [];
	
	for (i = 0; i < 6; i++)
	{
		var tempArr = [];
		for (j = 5; j >= 0; j--)
			tempArr.push(Math.pow(points[i][0], j));
		matrixArrA.push(tempArr);
	}
	
	var matrixA = math.matrix(matrixArrA);
	var matrixB = math.matrix([points[0][1], points[1][1], points[2][1], points[3][1], points[4][1], points[5][1]]);
	var coefficients = math.multiply(math.inv(matrixA), matrixB);
	return coefficients;
}

//Gets the y-value of a 5th degree polynomial defined by coefficients at x
function f(x, coefficients)
{
	var sum = 0;
	for (i = 5; i >= 0; i--)
	{
		sum += Math.pow(x, i) * coefficients[5 - i];
	} 
	return sum;
}

//Gets dy/dx of a 5th degree polynomial defined by coefficients at x
function derivative(x, coefficients)
{
	var sum = 0;
	for (i = 4; i >= 0; i--)
	{
		sum += (i + 1) * Math.pow(x, i) * coefficients[4 - i];
	} 
	return sum;
}

//Gets d2y/dx2 of a 5th degree polynomial defined by coefficients at x
function acceleration(x, coefficients)
{
	var sum = 0;
	for (i = 3; i >= 0; i--)
	{
		sum += (i + 2) * (i + 1) * Math.pow(x, i) * coefficients[3 - i];
	} 
	return sum;
}

function getUpperAndLowerPathPts(xOrig, yOrig, m, spacing)
{
	var pts = [];
	if (Math.abs(m) < 0.0001)
	{
		pts.push([xOrig, yOrig + spacing]);
		pts.push([xOrig, yOrig - spacing]);
	}
	else
	{
		var perpendicular = -1 / m;
		var dx = Math.sqrt((spacing * spacing) / (1 + perpendicular * perpendicular));
		var dy = dx * perpendicular;
		if (m > 0)
		{
			pts.push([xOrig - dx, yOrig - dy]);
			pts.push([xOrig + dx, yOrig + dy]);
		}
		else
		{
			pts.push([xOrig + dx, yOrig + dy]);
			pts.push([xOrig - dx, yOrig - dy]);
		}
	}
	return pts;
}

function drawPolynomial(constants, upperLimit, ctx)
{
	ctx.beginPath();
	var scale = 700 / (upperLimit + 1);
	ctx.moveTo(0, 800 - f(0, constants));
	for (k = 0; k < upperLimit; k+= 0.01)
	{
		ctx.lineTo(k * scale, 800 - f(k , constants) * scale);
	}
	ctx.stroke();
}

function generateComponentParts(centerCons, lowerLimit, upperLimit, rAcc, rSpeed, v1, v2, timeInterval, space)
{
	var totalTime = 0;
	var totalLength = 0;
	var STEP_SIZE = 0.00001;
	var TIME_STEP = 0.5;
	for (j = lowerLimit; j < upperLimit; j+= STEP_SIZE)
	{
		totalLength += math.sqrt(1 + Math.pow(derivative(j, centerCons), 2)) * STEP_SIZE;
	} 

	var timeAccelerating = (rSpeed - v1) / rAcc;
	var lengthAccelerating = (v1 + rSpeed) / 2 * timeAccelerating;
	
	var timeDeccelerating = (rSpeed - v2) / rAcc;
	var lengthDeccelerating = (rSpeed + v2) / 2 * timeDeccelerating;
	
	var lengthConsSpeed = totalLength - lengthAccelerating - lengthDeccelerating;
	var timeConsSpeed = lengthConsSpeed / rSpeed;
	console.log(timeAccelerating);
	console.log(timeConsSpeed);
	console.log(timeDeccelerating);
	totalTime = timeAccelerating + timeDeccelerating + timeConsSpeed;

	var upperPts = [];//format: [x, y, vel]
	var lowerPts = [];
	var xTraveled = lowerLimit;
	context.fillStyle = "#ff0000";
	var tick = 0;
	for(time = 0; time < timeAccelerating; time += TIME_STEP)
	{
		var distToTravel = (rAcc * time + rAcc * (time + TIME_STEP)) / 2 * TIME_STEP;
		while (distToTravel >= 0)
		{
			distToTravel -= math.sqrt(1 + Math.pow(derivative(xTraveled, centerCons), 2)) * STEP_SIZE;
			xTraveled += STEP_SIZE;
		}
		tick++;
		context.fillStyle = "#000000"
		context.fillRect(xTraveled * 700 / (p2['x'] + 1) - 2.5, 800 - f(xTraveled, centerCons) * 700 / (p2['x'] + 1) - 2.5, 5, 5);
		context.fillStyle = "#ff0000";
		var pts = getUpperAndLowerPathPts(xTraveled, f(xTraveled, centerCons), derivative(xTraveled, centerCons), space);
		var upperPt = pts[0];
		var lowerPt = pts[1];
	
		if (upperPts.length != 0)
		{
			upperPt.push(Math.sqrt(Math.pow(upperPt[0] - upperPts[upperPts.length - 1][0], 2) + Math.pow(upperPt[1] - upperPts[upperPts.length - 1][1], 2)) / TIME_STEP);
			lowerPt.push(Math.sqrt(Math.pow(lowerPt[0] - lowerPts[lowerPts.length - 1][0], 2) + Math.pow(lowerPt[1] - lowerPts[lowerPts.length - 1][1], 2)) / TIME_STEP);
		}
		else
		{
			upperPt.push(0);
			lowerPt.push(0);
		}
		upperPts.push(upperPt);
		lowerPts.push(lowerPt);
		context.fillRect(upperPt[0] * 700 / (p2['x'] + 1) - 2.5, 800 - upperPt[1] * 700 / (p2['x'] + 1) - 2.5, 5, 5);
		context.fillRect(lowerPt[0] * 700 / (p2['x'] + 1) - 2.5, 800 - lowerPt[1] * 700 / (p2['x'] + 1) - 2.5, 5, 5);
	}
	
	
	for (time = timeAccelerating; time < timeAccelerating + timeConsSpeed; time += TIME_STEP)
	{
		var distToTravel = rSpeed * TIME_STEP;
		while (distToTravel >= 0)
		{
			distToTravel -= math.sqrt(1 + Math.pow(derivative(xTraveled, centerCons), 2)) * STEP_SIZE;
			xTraveled += STEP_SIZE;
		}
		tick++;
		context.fillStyle = "#000000"
		context.fillRect(xTraveled * 700 / (p2['x'] + 1) - 2.5, 800 - f(xTraveled, centerCons) * 700 / (p2['x'] + 1) - 2.5, 5, 5);
		context.fillStyle = "#00ff00";
		
		var pts = getUpperAndLowerPathPts(xTraveled, f(xTraveled, centerCons), derivative(xTraveled, centerCons), space);
		var upperPt = pts[0];
		var lowerPt = pts[1];
	
		if (upperPts.length != 0)
		{
			upperPt.push(Math.sqrt(Math.pow(upperPt[0] - upperPts[upperPts.length - 1][0], 2) + Math.pow(upperPt[1] - upperPts[upperPts.length - 1][1], 2)) / TIME_STEP);
			lowerPt.push(Math.sqrt(Math.pow(lowerPt[0] - lowerPts[lowerPts.length - 1][0], 2) + Math.pow(lowerPt[1] - lowerPts[lowerPts.length - 1][1], 2)) / TIME_STEP);
		}
		else
		{
			upperPt.push(0);
			lowerPt.push(0);
		}
		upperPts.push(upperPt);
		lowerPts.push(lowerPt);

		context.fillRect(upperPt[0] * 700 / (p2['x'] + 1) - 2.5, 800 - upperPt[1] * 700 / (p2['x'] + 1) - 2.5, 5, 5);
		context.fillRect(lowerPt[0] * 700 / (p2['x'] + 1) - 2.5, 800 - lowerPt[1] * 700 / (p2['x'] + 1) - 2.5, 5, 5);
	}
	
	
	for (time = timeAccelerating + timeConsSpeed; time < totalTime; time += TIME_STEP)
	{
		var distToTravel = ((v2 + (totalTime - time) * rAcc) + (v2 + (totalTime - time + TIME_STEP) * rAcc)) / 2 * TIME_STEP;
		while (distToTravel >= 0)
		{
			distToTravel -= math.sqrt(1 + Math.pow(derivative(xTraveled, centerCons), 2)) * STEP_SIZE;
			xTraveled += STEP_SIZE;
		}
		if (xTraveled > upperLimit)
			xTraveled = upperLimit;
		tick++;
		context.fillStyle = "#000000"
		context.fillRect(xTraveled * 700 / (p2['x'] + 1) - 2.5, 800 - f(xTraveled, centerCons) * 700 / (p2['x'] + 1) - 2.5, 5, 5);
		context.fillStyle = "#0000ff";
		
		var pts = getUpperAndLowerPathPts(xTraveled, f(xTraveled, centerCons), derivative(xTraveled, centerCons), space);
		var upperPt = pts[0];
		var lowerPt = pts[1];
	
		if (upperPts.length != 0)
		{
			upperPt.push(Math.sqrt(Math.pow(upperPt[0] - upperPts[upperPts.length - 1][0], 2) + Math.pow(upperPt[1] - upperPts[upperPts.length - 1][1], 2)) / TIME_STEP);
			lowerPt.push(Math.sqrt(Math.pow(lowerPt[0] - lowerPts[lowerPts.length - 1][0], 2) + Math.pow(lowerPt[1] - lowerPts[lowerPts.length - 1][1], 2)) / TIME_STEP);
		}
		else
		{
			upperPt.push(0);
			lowerPt.push(0);
		}
		upperPts.push(upperPt);
		lowerPts.push(lowerPt);
		context.fillRect(upperPt[0] * 700 / (p2['x'] + 1) - 2.5, 800 - upperPt[1] * 700 / (p2['x'] + 1) - 2.5, 5, 5);
		context.fillRect(lowerPt[0] * 700 / (p2['x'] + 1) - 2.5, 800 - lowerPt[1] * 700 / (p2['x'] + 1) - 2.5, 5, 5);
	}
	console.log(tick);
	console.log("UPPER PTS:\n");
	for (b = 0; b < upperPts.length; b++)
		console.log(upperPts[b][2]);
	console.log("LOWER PTS:\n");
	for (b = 0; b < lowerPts.length; b++)
		console.log(lowerPts[b][2]);
}

var p1 = {x: 3, y: 35};
var vel1 = {x: 0, y: 0};
var acc1 = {x: 0, y: -0.5};

var p2 = {x: 35, y: 5};
var vel2 = {x: 0.5, y: 0.5};
var acc2 = {x: 0, y: 0.5};
var robotMaxSpeed = 3;//2 inches per second
var robotAcc = 1.0;//0.5 inch per second per second
var halfRobotWidth = 0.5;

var centerPathConstants = getPolynomialConstants(p1, p2, vel1, vel2, acc1, acc2);

drawPolynomial(centerPathConstants, p2['x'], context);
generateComponentParts(centerPathConstants, p1['x'], p2['x'], robotAcc, robotMaxSpeed, Math.sqrt(vel1['x'] * vel1['x'] + vel1['y'] * vel1['y']), Math.sqrt(vel2['x'] * vel2['x'] + vel2['y'] * vel2['y']), 20, halfRobotWidth);

//for (kk = 3; kk < 5; kk += 0.2)
//{	
//	context.beginPath();
//	context.arc(kk * 700 / (p2['x'] + 1), 800 - f(kk, centerPathConstants) * 700 / (p2['x'] + 1), 0.5 * 700 / (p2['x'] + 1), 0, 2 * 3.141592)
//	context.stroke();
//}
</script>
</body>
</html>