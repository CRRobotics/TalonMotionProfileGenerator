<html>
<head>
<title>Path Generator</title>
<script src="math.js"></script>
</head>
<body>
<canvas id="bgCanvas" style="position:absolute;z-index:0;"></canvas>
<canvas id="myCanvas" style="position:absolute;z-index:1;"></canvas>
<script>
var c = document.getElementById("myCanvas");
c.onclick = canvasClicked;
var context = c.getContext("2d");
var img = document.getElementById("field");
var height = 0;
var width = 0;
base_image = new Image();
base_image.src = 'Field_small.png';

base_image.onload = setupCanvas;

//	Works for 5th degree polynomials
//	Takes in 2 pts, 2 velocity vectors, 2 acceleration vectors
function getPolynomialConstants(pt1, pt2, v1, v2, a1, a2)
{
	var matrixA = math.matrix([[Math.pow(pt1['x'], 5), Math.pow(pt1['x'], 4), Math.pow(pt1['x'], 3), Math.pow(pt1['x'], 2), Math.pow(pt1['x'], 1), 1],
					[Math.pow(pt2['x'], 5), Math.pow(pt2['x'], 4), Math.pow(pt2['x'], 3), Math.pow(pt2['x'], 2), Math.pow(pt2['x'], 1), 1],
					[5 * Math.pow(pt1['x'], 4), 4 * Math.pow(pt1['x'], 3), 3 * Math.pow(pt1['x'], 2), 2 * Math.pow(pt1['x'], 1), 1, 0],
					[5 * Math.pow(pt2['x'], 4), 4 * Math.pow(pt2['x'], 3), 3 * Math.pow(pt2['x'], 2), 2 * Math.pow(pt2['x'], 1), 1, 0],
					[20 * Math.pow(pt1['x'], 3), 12 * Math.pow(pt1['x'], 2), 6 * Math.pow(pt1['x'], 1), 2, 0, 0],
					[20 * Math.pow(pt2['x'], 3), 12 * Math.pow(pt2['x'], 2), 6 * Math.pow(pt2['x'], 1), 2, 0, 0]]);
	//vDir1 = (v1['x'] == 0) ? 0 : v1['y'] / v1['x'];
	//vDir2 = (v2['x'] == 0) ? 0 : v2['y'] / v2['x'];
	var matrixB = math.matrix([pt1['y'], pt2['y'], v1['y'], v2['y'], a1['y'], a2['y']]);
	var coefficients = math.multiply(math.inv(matrixA), matrixB);
	return coefficients._data;
}

function getPolynomialConstantsFromPtsOnly(points)
{
	var matrixArrA = [];
	
	for (i = 0; i < 6; i++)
	{
		var tempArr = [];
		for (j = 5; j >= 0; j--)
			tempArr.push(Math.pow(points[i][0], j));
		matrixArrA.push(tempArr);
	}
	
	var matrixA = math.matrix(matrixArrA);
	var matrixB = math.matrix([points[0][1], points[1][1], points[2][1], points[3][1], points[4][1], points[5][1]]);
	var coefficients = math.multiply(math.inv(matrixA), matrixB);
	return coefficients;
}

//Gets the y-value of a 5th degree polynomial defined by coefficients at x
function f(x, coefficients)
{
	var sum = 0;
	for (i = 5; i >= 0; i--)
	{
		sum += Math.pow(x, i) * coefficients[5 - i];
	} 
	return sum;
}

//Gets dy/dx of a 5th degree polynomial defined by coefficients at x
function derivative(x, coefficients)
{
	var sum = 0;
	for (i = 4; i >= 0; i--)
	{
		sum += (i + 1) * Math.pow(x, i) * coefficients[4 - i];
	} 
	return sum;
}

//Gets d2y/dx2 of a 5th degree polynomial defined by coefficients at x
function acceleration(x, coefficients)
{
	var sum = 0;
	for (i = 3; i >= 0; i--)
	{
		sum += (i + 2) * (i + 1) * Math.pow(x, i) * coefficients[3 - i];
	} 
	return sum;
}

function getUpperAndLowerPathPts(xOrig, yOrig, m, spacing)
{
	var pts = [];
	if (Math.abs(m) < 0.0001)
	{
		pts.push([xOrig, yOrig + spacing]);
		pts.push([xOrig, yOrig - spacing]);
	}
	else
	{
		var perpendicular = -1 / m;
		var dx = Math.sqrt((spacing * spacing) / (1 + perpendicular * perpendicular));
		var dy = dx * perpendicular;
		if (m > 0)
		{
			pts.push([xOrig - dx, yOrig - dy]);
			pts.push([xOrig + dx, yOrig + dy]);
		}
		else
		{
			pts.push([xOrig + dx, yOrig + dy]);
			pts.push([xOrig - dx, yOrig - dy]);
		}
	}
	return pts;
}

function drawPolynomial(constants, upperLimit, ctx)
{
	ctx.beginPath();
	var scale = 700 / (upperLimit + 1);
	ctx.moveTo(0, 800 - f(0, constants));
	for (k = 0; k < upperLimit; k+= 0.01)
	{
		ctx.lineTo(k * scale, 800 - f(k , constants) * scale);
	}
	ctx.stroke();
}

function generateComponentParts(centerCons, lowerLimit, upperLimit, rAcc, rSpeed, v1, v2, timeInterval, space)
{
	var totalTime = 0;
	var totalLength = 0;
	var STEP_SIZE = 0.00001;
	var TIME_STEP = 0.25;
	for (j = lowerLimit; j < upperLimit; j+= STEP_SIZE)
	{
		totalLength += math.sqrt(1 + Math.pow(derivative(j, centerCons), 2)) * STEP_SIZE;
	} 

	var timeAccelerating = (rSpeed - v1) / rAcc;
	var lengthAccelerating = (v1 + rSpeed) / 2 * timeAccelerating;
	
	var timeDeccelerating = (rSpeed - v2) / rAcc;
	var lengthDeccelerating = (rSpeed + v2) / 2 * timeDeccelerating;
	
	var lengthConsSpeed = totalLength - lengthAccelerating - lengthDeccelerating;
	var timeConsSpeed = lengthConsSpeed / rSpeed;
	console.log(timeAccelerating);
	console.log(timeConsSpeed);
	console.log(timeDeccelerating);
	totalTime = timeAccelerating + timeDeccelerating + timeConsSpeed;

	var upperPts = [];//format: [x, y, vel]
	var lowerPts = [];
	var xTraveled = lowerLimit;
	context.fillStyle = "#ff0000";
	var tick = 0;
	for(time = 0; time < timeAccelerating; time += TIME_STEP)
	{
		var distToTravel = (rAcc * time + rAcc * (time + TIME_STEP)) / 2 * TIME_STEP;
		while (distToTravel >= 0)
		{
			distToTravel -= math.sqrt(1 + Math.pow(derivative(xTraveled, centerCons), 2)) * STEP_SIZE;
			xTraveled += STEP_SIZE;
		}
		tick++;
		context.fillStyle = "#000000"
		context.fillRect(xTraveled - 2.5, 800 - f(xTraveled, centerCons) - 2.5, 5, 5);
		context.fillStyle = "#ff0000";
		var pts = getUpperAndLowerPathPts(xTraveled, f(xTraveled, centerCons), derivative(xTraveled, centerCons), space);
		var upperPt = pts[0];
		var lowerPt = pts[1];
	
		if (upperPts.length != 0)
		{
			upperPt.push(Math.sqrt(Math.pow(upperPt[0] - upperPts[upperPts.length - 1][0], 2) + Math.pow(upperPt[1] - upperPts[upperPts.length - 1][1], 2)) / TIME_STEP);
			lowerPt.push(Math.sqrt(Math.pow(lowerPt[0] - lowerPts[lowerPts.length - 1][0], 2) + Math.pow(lowerPt[1] - lowerPts[lowerPts.length - 1][1], 2)) / TIME_STEP);
		}
		else
		{
			upperPt.push(0);
			lowerPt.push(0);
		}
		upperPts.push(upperPt);
		lowerPts.push(lowerPt);
		context.fillRect(upperPt[0] - 2.5, 800 - upperPt[1] - 2.5, 5, 5);
		context.fillRect(lowerPt[0] - 2.5, 800 - lowerPt[1] - 2.5, 5, 5);
	}
	
	
	for (time = timeAccelerating; time < timeAccelerating + timeConsSpeed; time += TIME_STEP)
	{
		var distToTravel = rSpeed * TIME_STEP;
		while (distToTravel >= 0)
		{
			distToTravel -= math.sqrt(1 + Math.pow(derivative(xTraveled, centerCons), 2)) * STEP_SIZE;
			xTraveled += STEP_SIZE;
		}
		tick++;
		context.fillStyle = "#000000"
		context.fillRect(xTraveled - 2.5, 800 - f(xTraveled, centerCons) - 2.5, 5, 5);
		context.fillStyle = "#00ff00";
		
		var pts = getUpperAndLowerPathPts(xTraveled, f(xTraveled, centerCons), derivative(xTraveled, centerCons), space);
		var upperPt = pts[0];
		var lowerPt = pts[1];
	
		if (upperPts.length != 0)
		{
			upperPt.push(Math.sqrt(Math.pow(upperPt[0] - upperPts[upperPts.length - 1][0], 2) + Math.pow(upperPt[1] - upperPts[upperPts.length - 1][1], 2)) / TIME_STEP);
			lowerPt.push(Math.sqrt(Math.pow(lowerPt[0] - lowerPts[lowerPts.length - 1][0], 2) + Math.pow(lowerPt[1] - lowerPts[lowerPts.length - 1][1], 2)) / TIME_STEP);
		}
		else
		{
			upperPt.push(0);
			lowerPt.push(0);
		}
		upperPts.push(upperPt);
		lowerPts.push(lowerPt);

		context.fillRect(upperPt[0] - 2.5, 800 - upperPt[1] - 2.5, 5, 5);
		context.fillRect(lowerPt[0] - 2.5, 800 - lowerPt[1] - 2.5, 5, 5);
	}
	
	
	for (time = timeAccelerating + timeConsSpeed; time < totalTime; time += TIME_STEP)
	{
		var distToTravel = ((v2 + (totalTime - time) * rAcc) + (v2 + (totalTime - time + TIME_STEP) * rAcc)) / 2 * TIME_STEP;
		while (distToTravel >= 0)
		{
			distToTravel -= math.sqrt(1 + Math.pow(derivative(xTraveled, centerCons), 2)) * STEP_SIZE;
			xTraveled += STEP_SIZE;
		}
		if (xTraveled > upperLimit)
			xTraveled = upperLimit;
		tick++;
		context.fillStyle = "#000000"
		context.fillRect(xTraveled - 2.5, 800 - f(xTraveled, centerCons) - 2.5, 5, 5);
		context.fillStyle = "#0000ff";
		
		var pts = getUpperAndLowerPathPts(xTraveled, f(xTraveled, centerCons), derivative(xTraveled, centerCons), space);
		var upperPt = pts[0];
		var lowerPt = pts[1];
	
		if (upperPts.length != 0)
		{
			upperPt.push(Math.sqrt(Math.pow(upperPt[0] - upperPts[upperPts.length - 1][0], 2) + Math.pow(upperPt[1] - upperPts[upperPts.length - 1][1], 2)) / TIME_STEP);
			lowerPt.push(Math.sqrt(Math.pow(lowerPt[0] - lowerPts[lowerPts.length - 1][0], 2) + Math.pow(lowerPt[1] - lowerPts[lowerPts.length - 1][1], 2)) / TIME_STEP);
		}
		else
		{
			upperPt.push(0);
			lowerPt.push(0);
		}
		upperPts.push(upperPt);
		lowerPts.push(lowerPt);
		context.fillRect(upperPt[0]  - 2.5, 800 - upperPt[1] - 2.5, 5, 5);
		context.fillRect(lowerPt[0]  - 2.5, 800 - lowerPt[1] - 2.5, 5, 5);
	}
	//console.log("UPPER PTS:\n");
	//for (b = 0; b < upperPts.length; b++)
	//	console.log(upperPts[b][2]);
	//console.log("LOWER PTS:\n");
	//for (b = 0; b < lowerPts.length; b++)
	//	console.log(lowerPts[b][2]);
}

function toScreenX(inches)
{
    var height = window.innerHeight - 20;
    var width = height * 1.673;
	return inches * width / 59.91 / 12;
}

function toScreenY(inches)
{
	var height = window.innerHeight - 20;
    var width = height * 1.673;
	return height - inches * width / 59.91 /12;
}

function toInchesX(coord)
{
    var height = window.innerHeight - 20;
    var width = height * 1.673;
	return coord * 59.91 * 12 / width;
}

function toInchesY(coord)
{
	var height = window.innerHeight - 20;
    var width = height * 1.673;
	return (height - coord) * 59.91 * 12 / width;

}

var mode = 0;
var pts = [];
var vel = [];
var constants = [];//xParam at 0, yParam at 1
function canvasClicked(e)
{
	var x = (e.clientX) - 7;
	var y = (e.clientY) - 7;
	
	var pt = { x: toInchesX(x), y: toInchesY(y)};
	console.log(x + ", " + y);
	if (mode == 0)
	{
		mode = 1;
		pts.push(pt);
	}
	else if (mode == 1)
	{
		mode = 2;
		pts.push(pt);
	}
	else if (mode == 2)
	{
		mode = 1;
		dx = toInchesX(x) - pts[pts.length - 1].x
		dy = toInchesY(y) - pts[pts.length - 1].y
		vel.push({x:dx, y:dy});
		//Time to make polynomials!
		var vel1;
		var vel2 = vel[vel.length - 1];
		if (vel.length == 1)
			vel1 = {x: 0, y: 0}
		else
			vel1 = vel[vel.length - 2];
		
	}
}

function refresh()
{
	//context.drawImage(img, 0, 0);
}

function setupCanvas() {
    var c2 = document.getElementById("bgCanvas");
    var ctx2 = c2.getContext("2d");
    height = window.innerHeight - 20;
    width = height * 1.673;
    context.canvas.width = width;
    context.canvas.height = height;
    c2.width = width;
	c2.height = height;	
    ctx2.drawImage(base_image, 0, 0, width, height);
	//console.log("setup");
}

function drawWayPts() {
    for (var j = 0; j < pts.length; j++)
	{
        x = toScreenX(pts[j].x);
        y = toScreenY(pts[j].y);
        context.beginPath();
        context.arc(x, y, 5, 0, 2 * Math.PI);
        if (j == 0)
            context.fillStyle = 'green';
        else
            context.fillStyle = 'red';
        context.fill();
        context.lineWidth = 0;
        context.closePath();
        context.stroke();
    }
    for (var j = 0; j < vel.length; j++)
    {
    	context.lineWidth = 0.5;
    		x = pts[j + 1].x;
        	y = pts[j + 1].y;
    	dx = vel[j].x;
    	dy = vel[j].y;
    	VEL_LEN = 20;
    	if (dx == 0)
    	{
        	context.moveTo(toScreenX(x), toScreenY(y - VEL_LEN));
        	context.lineTo(toScreenX(x), toScreenY(y + VEL_LEN));
    	}
    	else
    	{
    		m = dy / dx;
    		console.log(m);
    		deltaX = Math.sqrt(VEL_LEN * VEL_LEN / (1 + m * m))
    		deltaY = deltaX * m;
    		context.moveTo(toScreenX(x - deltaX), toScreenY(y - deltaY));
    		context.lineTo(toScreenX(x + deltaX), toScreenY(y + deltaY));
    	}
    }
    context.stroke();
}

function draw() {
    context.clearRect(0, 0, c.width, c.height);
    if ((window.innerHeight - 20) != height) {
        //Browser has been resized
        setupCanvas();
    }
    drawWayPts();
    //...drawing code...
    //Runs often and fast
}

function loop() {
    window.setTimeout(loop, 15);
    draw();
}

setupCanvas();
loop();
</script>
</body>
</html>
